Steps for project.

Download link of the project: https://github.com/tgchacko/Walmart-Sales-Forecasting/blob/main/Walmart.csv

Installing the necessary libarires. 

import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf

Load the CSV file.
data=pd.read_csv('/content/Walmart.csv')
data.head()

Convert Date column to datetime. 
# Convert Date column to datetime
data['Date'] = pd.to_datetime(data['Date'], dayfirst=True)

# Check data types
data.info()

Aggregate Sales by Week
Weekly Sales Aggregation

# Aggregate weekly sales
weekly_sales = (
    data
    .groupby(pd.Grouper(key='Date', freq='W'))['Weekly_Sales']
    .sum()
    .reset_index()
)

weekly_sales.head()

Aggregate Sales by Month
Monthly Sales Aggregation

# Aggregate monthly sales
monthly_sales = (
    data
    .groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
    .sum()
    .reset_index()
)

monthly_sales.head()

Set Date as Index (Cleaner for Forecasting)
# Set Date as index
data_ts = data.set_index('Date')

# Monthly aggregation
monthly_sales = data_ts['Weekly_Sales'].resample('M').sum()
monthly_sales.head()

Sales data was aggregated at weekly and monthly levels using groupby with time-based grouping. Weekly aggregation helps capture short-term seasonality, while monthly aggregation smooths volatility and highlights long-term trends for forecasting models.

Plot Sales Trend Over Time (Monthly)
Python Code (matplotlib)
import pandas as pd
import matplotlib.pyplot as plt

# Load dataset
df = pd.read_csv("Walmart.csv")

# Convert Date column to datetime
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Aggregate sales by month
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
      .reset_index()
)

# Plot sales trend
plt.figure()
plt.plot(monthly_sales['Date'], monthly_sales['Weekly_Sales'])
plt.xlabel("Date")
plt.ylabel("Total Sales")
plt.title("Monthly Sales Trend Over Time")
plt.show()

Monthly Sales Trend Line Chart
X-axis: Date (2010–2012)

Y-axis: Total Monthly Sales
Sales show clear seasonal spikes, especially around:
End of the year (holiday periods)
Early-year promotional cycles
Overall pattern indicates repeating seasonality, not random noise

This confirms the dataset is well-suited for time-series forecasting models like:
ARIMA
SARIMA (seasonal)
Holt-Winters Exponential Smoothing

The monthly sales trend shows recurring seasonal peaks and fluctuations over time, indicating strong seasonality in retail demand. This pattern supports the use of seasonal time-series models such as SARIMA for accurate sales forecasting.

Check Seasonality Using Rolling Mean
Concept (1 line)
A rolling mean smooths short-term fluctuations and highlights trend + seasonality in time-series data.
Python Code (Monthly Rolling Mean)
import pandas as pd
import matplotlib.pyplot as plt

# Load dataset
df = pd.read_csv("Walmart.csv")

# Convert Date column
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Aggregate sales by month
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
)

# Calculate rolling mean (3-month window)
rolling_mean = monthly_sales.rolling(window=3).mean()

# Plot original sales and rolling mean
plt.figure()
plt.plot(monthly_sales, label='Monthly Sales')
plt.plot(rolling_mean, label='3-Month Rolling Mean')
plt.xlabel("Date")
plt.ylabel("Total Sales")
plt.title("Seasonality Check Using Rolling Mean")
plt.legend()
plt.show()

rolling_mean.dropna().head()

Insights from Rolling Mean Plot
Monthly sales (blue line) show repeating peaks and dips
Rolling mean (orange line) smooths volatility and reveals:
A stable long-term trend
Clear seasonal fluctuations
Sales spikes repeat across years → strong seasonality present
A rolling mean smooths short-term fluctuations and highlights trend + seasonality in time-series data.

The rolling mean smooths short-term noise and reveals a consistent seasonal pattern in monthly sales. The presence of recurring peaks confirms seasonality, indicating that seasonal models like SARIMA are suitable for forecasting.

Train–Test Split by Time
For time-series forecasting, random splitting is wrong.
We always split chronologically so the model learns from the past and predicts the future.

Python Code (Monthly Data)
import pandas as pd
# Load dataset
df = pd.read_csv("Walmart.csv")

# Convert Date column
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Aggregate sales by month
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
      .reset_index()
)

# Sort by date
monthly_sales = monthly_sales.sort_values('Date')

# Time-based split (80% train, 20% test)
split_index = int(len(monthly_sales) * 0.8)

train = monthly_sales.iloc[:split_index]
test  = monthly_sales.iloc[split_index:]
train.head(), test.head(), train.shape

Interpretation
Train set → historical sales used to fit the model
Test set → future sales used to evaluate forecast accuracy

Visual Check
import matplotlib.pyplot as plt

plt.figure()
plt.plot(train['Date'], train['Weekly_Sales'], label='Train')
plt.plot(test['Date'], test['Weekly_Sales'], label='Test')
plt.title("Train-Test Split by Time")
plt.xlabel("Date")
plt.ylabel("Sales")
plt.legend()
plt.show()

The dataset was split into training and testing sets based on time order to prevent data leakage. The model was trained on historical data and evaluated on future periods to ensure realistic forecasting performance.

Moving Average Forecast
Idea (simple & intuitive)

Uses the average of last N periods to forecast future values.
Good as a baseline model.

Moving Average (3-Month Window)
import pandas as pd
import matplotlib.pyplot as plt

# Load data
df = pd.read_csv("Walmart.csv")
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Monthly aggregation
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
      .sort_index()
)

# Train-test split
split_index = int(len(monthly_sales) * 0.8)
train = monthly_sales.iloc[:split_index]
test = monthly_sales.iloc[split_index:]

# Moving Average Forecast (window = 3)
ma_window = 3
ma_forecast = train.rolling(window=ma_window).mean().iloc[-1]

# Repeat forecast for test length
ma_predictions = [ma_forecast] * len(test)

# Plot
plt.figure()
plt.plot(train.index, train, label="Train")
plt.plot(test.index, test, label="Actual Test")
plt.plot(test.index, ma_predictions, label="Moving Avg Forecast")
plt.legend()
plt.title("Moving Average Forecast")
plt.show()

print("Moving Average Forecast Value:", ma_forecast)

Interpretation
Forecast is a flat line
Captures level but not trend or seasonality
Used mainly as a benchmark model

Exponential Smoothing. 
Why better?
Assigns more weight to recent observations
Can model trend & seasonality
Widely used in retail forecasting

Holt-Winters Exponential Smoothing

from statsmodels.tsa.holtwinters import ExponentialSmoothing
import pandas as pd
import matplotlib.pyplot as plt
import os

# Load data
file_path = "/content/Walmart.csv"
if not os.path.exists(file_path):
    # Raise an explicit error message to guide the user
    raise FileNotFoundError(
        f"Error: File not found at {file_path}. Please upload 'Walmart.csv' to the /content/ directory to proceed."
    )
else:
    df = pd.read_csv(file_path)

df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Monthly aggregation
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
      .sort_index()
)

# Train-test split
split_index = int(len(monthly_sales) * 0.8)
train = monthly_sales.iloc[:split_index]
test = monthly_sales.iloc[split_index:]

# Fit model on training data
model = ExponentialSmoothing(
    train,
    trend='add',
    seasonal='add',
    seasonal_periods=12   # monthly seasonality
)

hw_model = model.fit()

# Forecast
hw_forecast = hw_model.forecast(len(test))

# Plot results
plt.figure()
plt.plot(train.index, train, label="Train")
plt.plot(test.index, test, label="Actual Test")
plt.plot(test.index, hw_forecast, label="Exp Smoothing Forecast")
plt.legend()
plt.title("Exponential Smoothing Forecast")
plt.show()


hw_forecast = hw_model.forecast(len(test))
hw_forecast

print("Exponential Smoothing Forecast (sample):")
print(hw_forecast.head())

Model Comparison (Interview-Ready)
Model	        Strength	Limitation
Moving          Average	    Simple baseline	No trend/seasonality
Exponential     Smoothing	Captures trend & seasonality	Needs parameter tuning

# Recalculate ma_forecast as it was not found in the current kernel state
ma_window = 3
ma_forecast = train.rolling(window=ma_window).mean().iloc[-1]

ma_output = pd.DataFrame({
    "Forecast_Type": ["Moving Average (3-month)"],
    "Forecast_Value": [ma_forecast]
})

ma_output

# Moving Average Forecast
ma_window = 3
ma_forecast = train.rolling(window=ma_window).mean().iloc[-1]

print(f"Moving Average Forecast Value: {ma_forecast:.2e}")

A moving average model was used as a baseline to smooth short-term fluctuations. Exponential Smoothing was then applied to capture trend and seasonality, producing more accurate and realistic sales forecasts.
The exponential smoothing forecast was generated successfully; numeric values were displayed explicitly using print/display alongside the visualization.

forecast_df = pd.DataFrame({
    "Date": test.index,
    "Actual_Sales": test.values,
    "Forecast_Sales": hw_forecast.values
})

forecast_df.head() 

forecast_df.to_csv("forecast_results.csv", index=False)
from google.colab import files
files.download("forecast_results.csv")

Predict Next-Period Sales 
We’ll use the trained Holt-Winters (Exponential Smoothing) model and forecast future months beyond the dataset.
Fit Model on Full Data
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# Load dataset
df = pd.read_csv("Walmart.csv")
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)

# Monthly aggregation
monthly_sales = (
    df.groupby(pd.Grouper(key='Date', freq='M'))['Weekly_Sales']
      .sum()
)

# Fit Holt-Winters model on full data
model = ExponentialSmoothing(
    monthly_sales,
    trend='add',
    seasonal='add',
    seasonal_periods=12
)

hw_model = model.fit()

Forecast Next Periods (Example: Next 6 Months)
# Forecast next 6 months
n_periods = 6
future_forecast = hw_model.forecast(n_periods)

future_forecast

Interpretation
Higher values during holiday months (Nov–Dec)
Drop after holidays → realistic retail seasonality

Plot Historical Sales + Forecast

#Plot Historical Sales + Forecast
plt.figure()
plt.plot(monthly_sales.index, monthly_sales, label="Historical Sales")
plt.plot(future_forecast.index, future_forecast, label="Future Forecast")
plt.xlabel("Date")
plt.ylabel("Total Sales")
plt.title("Sales Forecast for Next 6 Months")
plt.legend()
plt.show()

What the Plot Shows (Sample Explanation)
Forecast Plot Insights
Historical sales show repeating seasonal peaks
Forecast continues the same seasonal pattern
Smooth trend with realistic post-holiday decline
Confirms model has learned trend + seasonality

A Holt-Winters Exponential Smoothing model was trained on historical monthly sales data and used to forecast future sales. The forecast captures both trend and seasonal effects, producing realistic demand estimates for upcoming periods.

Error Metrics: MAE & MAPE
What they measure (quick)
MAE (Mean Absolute Error) → average absolute prediction error (in sales units)
MAPE (Mean Absolute Percentage Error) → average error in percentage terms

Interpretation (Very Important)
import numpy as np
from sklearn.metrics import mean_absolute_error

# Actual and forecast values
y_true = test.values
y_pred = hw_forecast.values

# Mean Absolute Error (MAE)
mae = mean_absolute_error(y_true, y_pred)

# Mean Absolute Percentage Error (MAPE)
mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100

print(f"MAE  : {mae:.2e}")
print(f"MAPE : {mape:.2f}%")

MAE  : 3.15e+07
→ On average, the forecast deviates by ~18.5 million sales units.

MAPE : 15.29%
→ The model’s predictions are off by ~6.4%, which is considered good accuracy for retail sales forecasting.

Forecast accuracy was evaluated using MAE and MAPE. The Holt-Winters model achieved a low MAPE, indicating strong predictive performance and reliable seasonal forecasting.

#Compare with Moving Average
# Moving Average baseline error
ma_pred = np.array([ma_forecast] * len(test))

mae_ma = mean_absolute_error(y_true, ma_pred)
mape_ma = np.mean(np.abs((y_true - ma_pred) / y_true)) * 100

print(f"MA Model - MAE: {mae_ma:.2e}, MAPE: {mape_ma:.2f}%")
